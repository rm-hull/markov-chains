<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Applications / Examples</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Markov-chains</span> <span class="project-version">0.1.1</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="background.html"><div class="inner"><span>Background</span></div></a></li><li class="depth-1 "><a href="basic-usage.html"><div class="inner"><span>Basic Usage</span></div></a></li><li class="depth-1  current"><a href="applications-examples.html"><div class="inner"><span>Applications / Examples</span></div></a></li><li class="depth-1 "><a href="references.html"><div class="inner"><span>References</span></div></a></li><li class="depth-1 "><a href="LICENSE.html"><div class="inner"><span>The MIT License (MIT)</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1 "><a href="markov-chains.core.html"><div class="inner"><span>markov-chains.core</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#applications-examples" name="applications-examples"></a>Applications / Examples</h1>
<p>The full code for these examples can be found in the <a href="https://github.com/rm-hull/markov-chains/blob/master/test/examples">test/examples</a> directory.</p>
<h3><a href="#text-generation" name="text-generation"></a>Text Generation</h3>
<p>Using some common (free) literature from <a href="https://www.gutenberg.org/">project gutenberg</a>:</p>
<pre><code class="clojure">(use 'markov-chains.core)

(def three-men-in-a-boat
  (-&gt;
    (slurp "test/examples/resources/308.txt")
    (clojure.string/split #"\s+")
    (collate 2)))

(-&gt;&gt;
  (generate three-men-in-a-boat)
  (take 60)
  (clojure.string/join " "))
; =&gt; "it oozed over the blackness, and heard Harris’s sleepy voice asking
;     where we drew near it, so they spread their handkerchiefs on the back
;     of Harris and Harris’s friend as to avoid running down which, we managed
;     to get out of here while this billing and cooing is on. We’ll go down
;     to eat vegetables. He said they were demons."
</code></pre>
<h3><a href="#algorithmic-music" name="algorithmic-music"></a>Algorithmic Music</h3>
<p>The <a href="https://en.wikipedia.org/wiki/Markov_chain#Music">Wikipedia page</a> on Markov chains shows a simple 1st-order matrix as follows:</p>
<table>
  <thead>
    <tr>
      <th>Note </th>
      <th align="right">A </th>
      <th align="right">C♯ </th>
      <th align="right">E♭ </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>A</strong> </td>
      <td align="right">0.1 </td>
      <td align="right">0.6 </td>
      <td align="right">0.3 </td>
    </tr>
    <tr>
      <td><strong>C♯</strong> </td>
      <td align="right">0.25 </td>
      <td align="right">0.05 </td>
      <td align="right">0.7 </td>
    </tr>
    <tr>
      <td><strong>E♭</strong> </td>
      <td align="right">0.7 </td>
      <td align="right">0.3 </td>
      <td align="right">0 </td>
    </tr>
  </tbody>
</table>
<p>We can easily represent this in code as (using the same MIDI notation as used with <code>overtone.live/note</code>):</p>
<pre><code class="clojure">(use 'markov-chains.core)

(def first-order-prob-matrix {
  [:A4]  { :A4 0.1  :C#4 0.6  :Eb4 0.3 }
  [:C#4] { :A4 0.25 :C#4 0.05 :Eb4 0.7 }
  [:Eb4] { :A4 0.7  :C#4 0.3  :Eb4 0 }})

(take 12 (generate first-order-prob-matrix))
; =&gt; (:Eb4 :A4 :C#4 :Eb4 :A4 :Eb4 :A4 :C#4 :Eb4 :A4 :C#4 :Eb4)
</code></pre>
<p>Obviously, the random nature means that the sequence will be different on each evaluation. <em>(Note to self: maybe should use a state monad for the random function)</em></p>
<p>The keys on the matrix represent the current system state, along with any previous state that also needs to be remembered: as this is a first-order matrix, only the current state is used. As shown in the next example, higher-order systems will need to consider past state as well in order to produce results with a sense of phrasal structure, rather than the aimless wandering of a first-order system.</p>
<p>This generated MIDI sequence can be then fed into overtone (make sure you have installed supercollider first):</p>
<pre><code class="clojure">(use 'overtone.live)

(definst saw-wave [freq 440 attack 0.01 sustain 0.4 release 0.1 vol 0.4]
  (* (env-gen (env-lin attack sustain release) 1 1 0 1 FREE)
     (saw freq)
     vol))

(defn saw2 [music-note]
  (saw-wave (midi-&gt;hz (note music-note))))

(defn play-chord [a-chord]
  (doseq [note a-chord] (saw2 note)))

(defn chord-progression-time [notes]
  (doseq [[time note] (map list (iterate (partial + 400) (now)) notes)]
    (at time (play-chord (chord note :major)))))

(chord-progression-time (take 24 (generate first-order-prob-matrix)))
</code></pre>
<p>For a 2nd-order matrix, we take the previous state into consideration as well as the current state:</p>
<table>
  <thead>
    <tr>
      <th>Note </th>
      <th align="right">A </th>
      <th align="right">D </th>
      <th align="right">G </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>AA</strong> </td>
      <td align="right">0.18 </td>
      <td align="right">0.6 </td>
      <td align="right">0.22 </td>
    </tr>
    <tr>
      <td><strong>AD</strong> </td>
      <td align="right">0.5 </td>
      <td align="right">0.5 </td>
      <td align="right">0 </td>
    </tr>
    <tr>
      <td><strong>AG</strong> </td>
      <td align="right">0.15 </td>
      <td align="right">0.75 </td>
      <td align="right">0.1 </td>
    </tr>
    <tr>
      <td><strong>DD</strong> </td>
      <td align="right">0 </td>
      <td align="right">0 </td>
      <td align="right">1 </td>
    </tr>
    <tr>
      <td><strong>DA</strong> </td>
      <td align="right">0.25 </td>
      <td align="right">0 </td>
      <td align="right">0.75 </td>
    </tr>
    <tr>
      <td><strong>DG</strong> </td>
      <td align="right">0.9 </td>
      <td align="right">0.1 </td>
      <td align="right">0 </td>
    </tr>
    <tr>
      <td><strong>GG</strong> </td>
      <td align="right">0.4 </td>
      <td align="right">0.4 </td>
      <td align="right">0.2 </td>
    </tr>
    <tr>
      <td><strong>GA</strong> </td>
      <td align="right">0.5 </td>
      <td align="right">0.25 </td>
      <td align="right">0.25 </td>
    </tr>
    <tr>
      <td><strong>GD</strong> </td>
      <td align="right">1 </td>
      <td align="right">0 </td>
      <td align="right">0 </td>
    </tr>
  </tbody>
</table>
<p>Representing this as follows:</p>
<pre><code class="clojure">(def second-order-prob-matrix {
  [:A4 :A4] { :A4 0.18 :D4 0.6  :G4 0.22 }
  [:A4 :D4] { :A4 0.5  :D4 0.5  :G4 0    }
  [:A4 :G4] { :A4 0.15 :D4 0.75 :G4 0.1  }
  [:D4 :D4] { :A4 0    :D4 0    :G4 1    }
  [:D4 :A4] { :A4 0.25 :D4 0    :G4 0.75 }
  [:D4 :G4] { :A4 0.9  :D4 0.1  :G4 0    }
  [:G4 :G4] { :A4 0.4  :D4 0.4  :G4 0.2  }
  [:G4 :A4] { :A4 0.5  :D4 0.25 :G4 0.25 }
  [:G4 :D4] { :A4 1    :D4 0    :G4 0    }})

(take 12 (generate second-order-prob-matrix))
; =&gt; (:D4 :A4 :G4 :G4 :D4 :A4 :G4 :D4 :A4 :A4 :A4 :D4)
</code></pre>
<p>Playing in overtone, gives a slighly less jarring rendition than the first-order system:</p>
<pre><code class="clojure">(chord-progression-time (take 40 (generate second-order-prob-matrix)))
</code></pre>
<blockquote>
  <p>TODO: Row-row-row your boat example</p>
</blockquote>
<h3><a href="#artificial-botany" name="artificial-botany"></a>Artificial Botany</h3>
<p>A realistic shrub can be generated with a formal <a href="https://github.com/rm-hull/lindenmayer-systems">L-system</a> grammar by repeatedly iterating the following rule and running the resultant operations through a <a href="https://github.com/rm-hull/turtle">logo-style interpreter</a>:</p>
<pre><code>F → F[+F]F[-F][F]
</code></pre>
<p>This results in a fairly uniform shrub structure as follows:</p>
<p><img src="https://rawgithub.com/rm-hull/markov-chains/master/test/examples/resources/formal_grammar_shrub.svg" alt="SVG" /></p>
<p>By taking the stream of operations that the L-system outputs (<code>:fwd</code>, <code>:left</code>, <code>:right</code>, etc.) and collating them into a probability matrix, we are now able to get the markov chains generator to emit a realistic stream of operations to pass to the logo drawing system.</p>
<pre><code class="clojure">(def shrub
  (-&gt;&gt;
    (l-system "F" ("^") ("F=F[+F]F[-F][F]"))
    (drop 5)
    first
    flatten))

(def second-order-prob-matrix (collate shrub 2))

(clojure.pprint/pprint second-order-prob-matrix)
; =&gt; {(:right :fwd) {:restore 625, :save 156},
;     (:save :fwd) {:restore 625, :save 156},
;     (:restore :save) {:fwd 781, :left 156, :right 156},
;     (:restore :restore) {:fwd 156, :save 218, :restore 93},
;     (:restore :fwd) {:save 781},
;     (:fwd :save) {:left 625, :right 625},
;     (:left :fwd) {:restore 625, :save 156},
;     (:save :right) {:fwd 781},
;     (:save :left) {:fwd 781},
;     (:fwd :restore) {:fwd 625, :save 875, :restore 375}}

(spit "markov_shrub.svg"
  (draw!
    -&gt;svg
    (augment (take 10000 (generate second-order-prob-matrix)))
    [800 600]))
</code></pre>
<p>See the <a href="https://github.com/rm-hull/markov-chains/blob/master/test/examples/botany.clj">source</a> for details on the <code>l-system</code> implementation. The generated SVG is random of course, but would look something like this:</p>
<p><img src="https://rawgithub.com/rm-hull/markov-chains/master/test/examples/resources/markov_shrub.svg" alt="SVG" /></p>
<h3><a href="#population-modelling" name="population-modelling"></a>Population Modelling</h3>
<p>In <em>Mathematische Abenteuer mit dem Computer</em>, <strong>L. Råde</strong> &amp; <strong>R.D. Nelson</strong> pose exercise 15.1 as follows:</p>
<p><img src="https://rawgithub.com/rm-hull/markov-chains/master/doc/population-modelling.svg" alt="SVG" /></p>
<blockquote>
  <p>In a certain country the movement of people between cities and the countryside is such that, in any one year, 20 per cent of those living in the countryside move to the cities, while 10 per cent of those living in the cities move to live in the countryside.</p>
  <p>Suppose that at the beginning of a year 5 million people live in the cities and 4 million live in the countryside. Write a program so that you can study the development year by year of the numbers of inhabitants in the cities and the countryside.</p>
</blockquote>
<p>Writing this program directly, might yield a solution as follows:</p>
<pre><code class="clojure">(defn population-modelling [town country]
  (cons
    [town country]
    (lazy-seq
      (population-modelling
        (+ (* town 0.9) (* country 0.2))
        (+ (* town 0.1) (* country 0.8))))))

(first (drop 1000 (population-modelling 5 4)))
; =&gt; [6.000000000000029 3.000000000000017]
</code></pre>
<p>Clearly the combined population of 9 million settles quite quicky into 6 million townsfolk and 3 million in the countryside. What is interesting is that any pair combination that adds upto 9 million ends up with the same value.</p>
<pre><code class="clojure">(first (drop 1000 (population-modelling 8.5 0.5)))
; =&gt; [6.000000000000021 3.0000000000000115]
</code></pre>
<p>Actual population migration will never of course be exactly as the model suggests, but we can use the probabilities in the exercise and create a corresponding probability matrix:</p>
<pre><code class="clojure">(def model {
  [:town]    { :town 0.9 :country 0.1 }
  [:country] { :town 0.2 :country 0.8 }})
</code></pre>
<p>And then some machinery to run the model and graph the results:</p>
<pre><code class="clojure">(use '(incanter core stats datasets charts))

(defn accumulator [data]
  (reductions
    (fn [acc value] (update acc value inc))
    (into {} (map vector (distinct data) (repeat 0)))
    data))

(defn ratio [kw]
 (fn [m]
  (double (/ (kw m) (apply + (vals m))))))

(view
  (line-chart
    (iterate inc 0)
    (-&gt;&gt;
      (generate model)
      (take 5000)
      accumulator
      next
      (map (ratio :town))
      (map (partial * 9)))
    :x-label "time"
    :y-label "town dwellers"))
</code></pre>
<p>Running this a few times illustrates that whatever starting point, the ratio of town dwellers to countryfolk settles to 2 to 1 over time:</p>
<p><img src="https://rawgithub.com/rm-hull/markov-chains/master/doc/pop1.png" alt="PNG" /> <img src="https://rawgithub.com/rm-hull/markov-chains/master/doc/pop2.png" alt="PNG" /> <img src="https://rawgithub.com/rm-hull/markov-chains/master/doc/pop3.png" alt="PNG" /></p>
<p>Using an even longer timeframe:</p>
<pre><code class="clojure">(-&gt;&gt;
  (generate model)
  (take 1000000)
  frequencies
  ((ratio :town))
  (* 9))
; =&gt; 5.9997419999999995
</code></pre></div></div></div></body></html>